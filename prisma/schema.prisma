generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                        String           @id @default(cuid())
  walletAddress             String           @unique
  username                  String?          @unique
  profilePictureUrl         String?
  createdAt                 DateTime         @default(now())
  updatedAt                 DateTime         @updatedAt
  nullifierHash             String?          @unique
  verificationLevel         String?
  isVerified                Boolean          @default(false)
  annoyIndexPosition        Int?             @unique
  communicationTone         String?
  currentAvailability       String           @default("available")
  currentCuriosity          String?
  essenceEmbeddingUpdatedAt DateTime?
  essenceKeywords           String?
  essenceStory              String?
  isActive                  Boolean          @default(true)
  lastActiveAt              DateTime         @default(now())
  locationCity              String?
  locationCountry           String?
  locationLat               Decimal?         @db.Decimal(10, 8)
  locationLng               Decimal?         @db.Decimal(11, 8)
  motivationForConnection   String?
  name                      String?
  onboardingCompleted       Boolean          @default(false)
  onboardingCompletedAt     DateTime?
  personalitySummary        String?
  sex                       String?
  successfulConnections     Int              @default(0)
  surroundingDetail         String?
  totalMatchesMade          Int              @default(0)
  dateOfBirth               DateTime?
  zodiacSign                String?
  baseFarcasterHandle       String?
  instagramHandle           String?
  linkedinHandle            String?
  telegramHandle            String?
  websiteUrl                String?
  xHandle                   String?
  zoraHandle                String?
  age                       Int?
  privateProfilePictureUrl  String?
  userWhy                   String?
  chatbotSessions           ChatbotSession[]
  receivedMessages          Message[]        @relation("MessageReceiver")
  sentMessages              Message[]        @relation("MessageSender")
  relatedRelations          Relationship[]   @relation("relatedUser")
  relatingRelations         Relationship[]   @relation("relatingUser")
  deployedPrompts           DeployedPrompt[]
  matchingSessions          MatchingSession[]
  matchResults              MatchResult[]
  userMatchHistory          UserMatchHistory[] @relation("UserMatchHistory")
  matchedUserHistory        UserMatchHistory[] @relation("MatchedUserHistory")

  @@map("users")
}

model Message {
  id          String      @id @default(cuid())
  content     String
  messageType MessageType @default(TEXT)
  senderId    String
  receiverId  String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  isRead      Boolean     @default(false)
  isEdited    Boolean     @default(false)
  receiver    User?       @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  sender      User        @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@map("messages")
}

model ChatbotSession {
  id          String           @id @default(cuid())
  userId      String
  botType     BotType
  sessionData Json?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  isActive    Boolean          @default(true)
  messages    ChatbotMessage[]
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("chatbot_sessions")
}

model ChatbotMessage {
  id        String         @id @default(cuid())
  sessionId String
  content   String
  isFromBot Boolean
  createdAt DateTime       @default(now())
  session   ChatbotSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@map("chatbot_messages")
}

model Relationship {
  id             String         @id @default(cuid())
  relationLevel  RELATION_LEVEL
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  relatingUserId String
  relatedUserId  String
  relatedUser    User           @relation("relatedUser", fields: [relatedUserId], references: [id])
  relatingUser   User           @relation("relatingUser", fields: [relatingUserId], references: [id])

  @@unique([relatingUserId, relatedUserId])
  @@map("relationships")
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  AUDIO
  VIDEO
}

enum BotType {
  SUPPORT
  WELLNESS
  FINANCIAL
  GENERAL
}

model Theme {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  prompts     Prompt[]
  deployedPrompts DeployedPrompt[]

  @@map("themes")
}

model Prompt {
  id          String   @id @default(cuid())
  themeId     String
  question    String
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  theme       Theme    @relation(fields: [themeId], references: [id], onDelete: Cascade)
  deployedPrompts DeployedPrompt[]

  @@map("prompts")
}

model DeployedPrompt {
  id                String            @id @default(cuid())
  userId            String
  promptId          String?
  customPrompt      String?
  themeId           String
  themeName         String
  question          String
  deployedAt        DateTime          @default(now())
  expiresAt         DateTime
  status            DeployedPromptStatus @default(ACTIVE)
  matchesShown      Boolean           @default(false)
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  prompt            Prompt?           @relation(fields: [promptId], references: [id], onDelete: SetNull)
  theme             Theme             @relation(fields: [themeId], references: [id], onDelete: Cascade)
  matchingSessions  MatchingSession[]

  @@map("deployed_prompts")
}


enum RELATION_LEVEL {
  PUBLIC
  COLLAB
  PRIVATE
}

enum DeployedPromptStatus {
  ACTIVE
  EXPIRED
  CANCELLED
}

model MatchingSession {
  id          String   @id @default(cuid())
  userId      String
  promptId    String
  status      String   @default("ACTIVE") // ACTIVE, COMPLETED, EXPIRED
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  prompt      DeployedPrompt @relation(fields: [promptId], references: [id], onDelete: Cascade)
  matchResults MatchResult[]

  @@map("matching_sessions")
}

model MatchResult {
  id                String   @id @default(cuid())
  sessionId         String
  matchedUserId     String
  compatibilityScore Float
  themeMatch        Boolean
  questionMatch     Boolean
  personalityMatch  Boolean
  locationMatch     Boolean
  createdAt         DateTime @default(now())

  session           MatchingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  matchedUser       User @relation(fields: [matchedUserId], references: [id], onDelete: Cascade)

  @@unique([sessionId, matchedUserId])
  @@map("match_results")
}

model UserMatchHistory {
  id            String   @id @default(cuid())
  userId        String
  matchedUserId String
  matchType     String   // "ACCEPTED", "DECLINED", "EXPIRED"
  sessionId     String?
  createdAt     DateTime @default(now())

  user          User     @relation("UserMatchHistory", fields: [userId], references: [id], onDelete: Cascade)
  matchedUser   User     @relation("MatchedUserHistory", fields: [matchedUserId], references: [id], onDelete: Cascade)

  @@unique([userId, matchedUserId])
  @@map("user_match_history")
}

