generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                        String             @id @default(cuid())
  walletAddress             String             @unique
  username                  String?            @unique
  profilePictureUrl         String?
  createdAt                 DateTime           @default(now())
  updatedAt                 DateTime           @updatedAt
  nullifierHash             String?            @unique
  verificationLevel         String?
  isVerified                Boolean            @default(false)
  annoyIndexPosition        Int?               @unique
  communicationTone         String?
  currentAvailability       String             @default("available")
  currentCuriosity          String?
  essenceEmbeddingUpdatedAt DateTime?
  essenceKeywords           String?
  essenceStory              String?
  isActive                  Boolean            @default(true)
  lastActiveAt              DateTime           @default(now())
  locationCity              String?
  locationCountry           String?
  locationLat               Decimal?           @db.Decimal(10, 8)
  locationLng               Decimal?           @db.Decimal(11, 8)
  motivationForConnection   String?
  name                      String?
  onboardingCompleted       Boolean            @default(false)
  onboardingCompletedAt     DateTime?
  personalitySummary        String?
  sex                       String?
  successfulConnections     Int                @default(0)
  surroundingDetail         String?
  totalMatchesMade          Int                @default(0)
  dateOfBirth               DateTime?
  zodiacSign                String?
  baseFarcasterHandle       String?
  instagramHandle           String?
  linkedinHandle            String?
  telegramHandle            String?
  websiteUrl                String?
  xHandle                   String?
  zoraHandle                String?
  age                       Int?
  privateProfilePictureUrl  String?
  userWhy                   String?
  chatbotSessions           ChatbotSession[]
  deployedPrompts           DeployedPrompt[]
  matchResults              MatchResult[]
  matchingSessions          MatchingSession[]
  receivedMessages          Message[]          @relation("MessageReceiver")
  sentMessages              Message[]          @relation("MessageSender")
  relatedRelations          Relationship[]     @relation("relatedUser")
  relatingRelations         Relationship[]     @relation("relatingUser")
  matchedUserHistory        UserMatchHistory[] @relation("MatchedUserHistory")
  userMatchHistory          UserMatchHistory[] @relation("UserMatchHistory")

  @@map("users")
}

model Message {
  id          String      @id @default(cuid())
  content     String
  messageType MessageType @default(TEXT)
  senderId    String
  receiverId  String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  isRead      Boolean     @default(false)
  isEdited    Boolean     @default(false)
  receiver    User?       @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  sender      User        @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@map("messages")
}

model ChatbotSession {
  id          String           @id @default(cuid())
  userId      String
  botType     BotType
  sessionData Json?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  isActive    Boolean          @default(true)
  messages    ChatbotMessage[]
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("chatbot_sessions")
}

model ChatbotMessage {
  id        String         @id @default(cuid())
  sessionId String
  content   String
  isFromBot Boolean
  createdAt DateTime       @default(now())
  session   ChatbotSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@map("chatbot_messages")
}

model Relationship {
  id             String         @id @default(cuid())
  relationLevel  RELATION_LEVEL
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  relatingUserId String
  relatedUserId  String
  relatedUser    User           @relation("relatedUser", fields: [relatedUserId], references: [id])
  relatingUser   User           @relation("relatingUser", fields: [relatingUserId], references: [id])

  @@unique([relatingUserId, relatedUserId])
  @@map("relationships")
}

model Theme {
  id              String           @id @default(cuid())
  name            String           @unique
  description     String?
  isActive        Boolean          @default(true)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  deployedPrompts DeployedPrompt[]
  prompts         Prompt[]

  @@map("themes")
}

model Prompt {
  id              String           @id @default(cuid())
  themeId         String
  question        String
  isActive        Boolean          @default(true)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  deployedPrompts DeployedPrompt[]
  theme           Theme            @relation(fields: [themeId], references: [id], onDelete: Cascade)

  @@map("prompts")
}

model DeployedPrompt {
  id               String               @id @default(cuid())
  userId           String
  promptId         String?
  customPrompt     String?
  themeId          String
  themeName        String
  question         String
  deployedAt       DateTime             @default(now())
  expiresAt        DateTime
  status           DeployedPromptStatus @default(ACTIVE)
  matchesShown     Boolean              @default(false)
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt
  prompt           Prompt?              @relation(fields: [promptId], references: [id])
  theme            Theme                @relation(fields: [themeId], references: [id], onDelete: Cascade)
  user             User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  matchingSessions MatchingSession[]

  @@map("deployed_prompts")
}

model MatchingSession {
  id           String         @id @default(cuid())
  userId       String
  promptId     String
  status       String         @default("ACTIVE")
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  matchResults MatchResult[]
  prompt       DeployedPrompt @relation(fields: [promptId], references: [id], onDelete: Cascade)
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("matching_sessions")
}

model MatchResult {
  id                 String          @id @default(cuid())
  sessionId          String
  matchedUserId      String
  compatibilityScore Float
  themeMatch         Boolean
  questionMatch      Boolean
  personalityMatch   Boolean
  locationMatch      Boolean
  createdAt          DateTime        @default(now())
  confirmed_at       DateTime?
  status             MatchStatus     @default(PENDING)
  user1_accepted     Boolean         @default(false)
  user2_accepted     Boolean         @default(false)
  matchedUser        User            @relation(fields: [matchedUserId], references: [id], onDelete: Cascade)
  session            MatchingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, matchedUserId])
  @@map("match_results")
}

model UserMatchHistory {
  id            String   @id @default(cuid())
  userId        String
  matchedUserId String
  matchType     String
  sessionId     String?
  createdAt     DateTime @default(now())
  matchedUser   User     @relation("MatchedUserHistory", fields: [matchedUserId], references: [id], onDelete: Cascade)
  user          User     @relation("UserMatchHistory", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, matchedUserId])
  @@map("user_match_history")
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  AUDIO
  VIDEO
}

enum BotType {
  SUPPORT
  WELLNESS
  FINANCIAL
  GENERAL
}

enum RELATION_LEVEL {
  PUBLIC
  COLLAB
  PRIVATE
}

enum DeployedPromptStatus {
  ACTIVE
  EXPIRED
  CANCELLED
}

enum MatchStatus {
  PENDING
  CONFIRMED
  DECLINED
  EXPIRED
}
